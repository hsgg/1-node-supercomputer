<!DOCTYPE html>
<html>

<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Welcome to my 2-node Supercomputer!</title>
<style>
    @media (prefers-color-scheme: light) {
        :root {
            background: white;
            color: #333;
            --readmorecolor: blue;
        }
        a:link {
            color: blue;
        }
        a:visited {
            color: purple;
        }
    }
    @media (prefers-color-scheme: dark) {
        :root {
            background: #222;
            color: #ddd;
            --readmorecolor: #74a0ff; /* light blue */
        }
        a:link {
            color: #add8ff;  /* darker blue than lightblue */
        }
        a:visited {
            color: #b695c0;  /* a light purple */
        }
    }
    @media screen and (max-width: 55ch) {
        :root {
            width: 100vw-2ch;
        }
    }
    html {
        max-width: 55ch;
        margin-left: auto;
        margin-right: auto;
        padding-left: 1ch;
        padding-right: 1ch;
        justify-content: center;
    }
    body {
        text-align: justify;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
    footer {
        padding-top: 1em;
        bottom: 0;
    }
    h1 {
        text-align: left;
    }
    pre {
        margin: 0 4em;
    }
</style>
</head>
<!-- vim: set sw=4 sts=4 et : -->

<body>
<p style=text-align:left;><em><a href=http://2-node-supercomputer.net>2-node-supercomputer.net</a></em>
<span style=float:right;>2024-10-03</span></p>

<h1
id="reproducible-updatable-and-developable-science-software">Reproducible,
Updatable, and Developable Science Software</h1>
<p>Reproducible builds, reproducible environments, reproducible science:
it’s all the rage. There are plenty solutions to the reproducibility
problem: pip freeze, conda export, docker.</p>
<p>However, we don’t just want reproducible science. We also want to be
able to update our software and dependencies because of new features,
bug fixes, or reductions in complexity. Further, we want as similar
environments as possible on different CPU architectures and operating
systems.</p>
<p>The aforementioned solutions - pip freeze, conda export, and docker -
fail at this, though they certainly can be (and are) a part of the
solution.</p>
<p>What is needed is a machine-generated file that saves the exact
versions of each and every dependency of a dependency. That is what will
allow reproducible environments. In Julia these machine-generated files
are called <code>Manifest.toml</code>, in Python a good option is
<code>conda-lock.yml</code>.</p>
<p>In the case of <code>conda-lock</code>, architecture- and
OS-dependent lists can be saved. In Julia that tends to be less of a
problem, though maybe it will be with optional dependencies becoming an
option.</p>
<p>Then, to be updatable, one also needs a human-edited file that lists
the required direct dependencies. Without this it becomes very hard to
update as both direct and indirect dependencies can change. In Julia
this is recorded in <code>Project.toml</code>, for Python there are
several options - we use <code>environment.yaml</code>.</p>
<p>Finally, by “developable” I mean the following. We want to be able to
easily change a package. In Julia this is achieved by calling
<code>Pkg.develop(pkgname)</code>. In conda there used to be
<code>conda develop</code>, but that is deprecated, probably because
conda doesn’t just do Python anymore, and “develop” would need something
very different depending on the package. However, Python has editable
install via pip, which is what we use. It’s not as convenient to develop
any given package, but probably fine for us.</p>

<footer><p style=text-align:left;><em><a href=http://2-node-supercomputer.net>2-node-supercomputer.net</a></em>
<span style=float:right;>2024-10-03</span></p></footer>

</body>


</html>

<!DOCTYPE html>
<html>

<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Welcome to my 2-node Supercomputer!</title>
<style>
    @media (prefers-color-scheme: light) {
        :root {
            background: white;
            color: #333;
            --readmorecolor: blue;
        }
        a:link {
            color: blue;
        }
        a:visited {
            color: purple;
        }
    }
    @media (prefers-color-scheme: dark) {
        :root {
            background: #222;
            color: #ddd;
            --readmorecolor: #74a0ff; /* light blue */
        }
        a:link {
            color: #add8ff;  /* darker blue than lightblue */
        }
        a:visited {
            color: #b695c0;  /* a light purple */
        }
    }
    @media screen and (max-width: 55ch) {
        :root {
            width: 100vw-2ch;
        }
    }
    html {
        max-width: 55ch;
        margin-left: auto;
        margin-right: auto;
        padding-left: 1ch;
        padding-right: 1ch;
        justify-content: center;
    }
    body {
        text-align: justify;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
    footer {
        padding-top: 1em;
        bottom: 0;
    }
    h1 {
        text-align: left;
    }
    pre {
        margin: 0 4em;
    }
</style>
</head>
<!-- vim: set sw=4 sts=4 et : -->

<body>
<p style=text-align:left;><em><a href=http://2-node-supercomputer.net>2-node-supercomputer.net</a></em>
<span style=float:right;>2024-10-03</span></p>

<h1
id="reproducible-updatable-developable-and-independent-software-environments-for-science">Reproducible,
Updatable, Developable, and Independent Software Environments for
Science</h1>
<p>Reproducible builds, reproducible environments, reproducible science:
it’s all the rage. There are plenty solutions to the reproducibility
problem: pip freeze, conda export, docker.</p>
<p>However, we don’t just want reproducible science. We also want to be
able to update our software and dependencies because of new features,
bug fixes, or reductions in complexity. Further, we want as similar
environments as possible on different CPU architectures and operating
systems. Finally, we want different projects to have independent
environments.</p>
<p>The aforementioned solutions - pip freeze, conda export, and docker -
fail at this, though they certainly can be (and are) a part of the
solution.</p>
<p>What is needed is a machine-generated file that saves the exact
versions of each and every dependency of a dependency. That is what will
allow reproducible environments. In Julia these machine-generated files
are called <code>Manifest.toml</code>, in Python a good option is
<code>conda-lock.yml</code>.</p>
<p>In the case of <code>conda-lock</code>, architecture- and
OS-dependent lists can be saved. In Julia that tends to be less of a
problem, though maybe it will be with optional dependencies becoming an
option.</p>
<p>Then, to be updatable, one also needs a human-edited file that lists
the required direct dependencies. Without this it becomes very hard to
update as both direct and indirect dependencies can change. In Julia
this is recorded in <code>Project.toml</code>, for Python there are
several options - we use <code>environment.yaml</code>.</p>
<p>Third, by “developable” I mean the following. We want to be able to
easily change a package. In Julia this is achieved by calling
<code>Pkg.develop(pkgname)</code>. In conda there used to be
<code>conda develop</code>, but that is deprecated, probably because
conda doesn’t just do Python anymore, and “develop” would need something
very different depending on the package. However, Python has editable
install via pip, which is what we use. It’s not as convenient to develop
any given package, but probably fine for us.</p>
<p>Finally, if you have several projects, perhaps all using different
versions of the same software packages, you want each project to have
independent environments. One could even imagine nested environments,
where each sub-environemnt could have a different version of the same
package. However, unless you are making a Linux distribution, perhaps
one by the name of Gitix, I fail to see the use case for such nested
environments.</p>
<p>In conclusion, we don’t just want reproducible environments, we also
want to be able to update them, check out the git repo<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> of
any package and make changes, and we want to prevent different
environments from stepping on each others’ toes.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Yes, I am hoping most packages have a git repo.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<footer><p style=text-align:left;><em><a href=http://2-node-supercomputer.net>2-node-supercomputer.net</a></em>
<span style=float:right;>2024-10-03</span></p></footer>

</body>


</html>
